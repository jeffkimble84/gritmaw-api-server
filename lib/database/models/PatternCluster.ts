import { Schema, model, Document, Types } from 'mongoose';

export interface IClusterMember {
  patternId: string;
  membershipScore: number;
  joinedAt: Date;
  contributionWeight: number;
}

export interface IClusterEvolution {
  timestamp: Date;
  event: 'created' | 'merged' | 'split' | 'updated';
  description: string;
  metrics: {
    memberCount: number;
    avgSimilarity: number;
    stability: number;
  };
  triggeringPatterns?: string[];
}

export interface ISemanticFeature {
  dimension: string;
  value: number;
  importance: number;
  derivedFrom: string[];
}

export interface IPatternCluster extends Document {
  clusterId: string;
  name: string;
  description: string;
  createdAt: Date;
  lastUpdated: Date;
  
  // Cluster characteristics
  characteristics: {
    type: 'behavioral' | 'statistical' | 'temporal' | 'mixed';
    primaryDimensions: string[];
    semanticFeatures: ISemanticFeature[];
    centroid: number[];
    radius: number;
    density: number;
  };
  
  // Member patterns
  members: IClusterMember[];
  
  // Cluster quality metrics
  quality: {
    cohesion: number;      // How similar are members
    separation: number;    // How different from other clusters
    stability: number;     // How stable over time
    significance: number;  // Statistical significance
    confidence: number;    // Overall confidence
  };
  
  // Performance when applied
  performance: {
    applicationsCount: number;
    successRate: number;
    avgImpact: number;
    contextualPerformance: Map<string, {
      context: string;
      applications: number;
      successRate: number;
    }>;
  };
  
  // Evolution tracking
  evolution: IClusterEvolution[];
  
  // Relationships
  relationships: {
    parentCluster?: string;
    childClusters: string[];
    relatedClusters: Array<{
      clusterId: string;
      relationship: 'complements' | 'conflicts' | 'subsumes' | 'overlaps';
      strength: number;
    }>;
  };
  
  // Application rules
  applicationRules: {
    minimumConfidence: number;
    requiredContext: string[];
    exclusionContext: string[];
    combinationRules: Array<{
      withCluster: string;
      rule: 'enhance' | 'cancel' | 'modify';
      impact: number;
    }>;
  };
  
  // Metadata
  metadata: {
    tags: string[];
    autoGenerated: boolean;
    lastEvaluated: Date;
    evaluationSchedule: 'hourly' | 'daily' | 'weekly' | 'adaptive';
    archived: boolean;
  };
  
  // Instance methods
  addMember(patternId: string, membershipScore: number): Promise<IPatternCluster>;
  calculateContributionWeight(membershipScore: number): number;
  recalculateClusterMetrics(): Promise<void>;
  evaluatePerformance(context: string, success: boolean): Promise<IPatternCluster>;
}

const PatternClusterSchema = new Schema<IPatternCluster>({
  clusterId: {
    type: String,
    required: true,
    unique: true,
    index: true
  },
  name: {
    type: String,
    required: true
  },
  description: {
    type: String,
    required: true
  },
  createdAt: {
    type: Date,
    required: true,
    default: Date.now
  },
  lastUpdated: {
    type: Date,
    required: true,
    default: Date.now
  },
  
  characteristics: {
    type: {
      type: String,
      required: true,
      enum: ['behavioral', 'statistical', 'temporal', 'mixed']
    },
    primaryDimensions: [String],
    semanticFeatures: [{
      dimension: String,
      value: Number,
      importance: { type: Number, min: 0, max: 1 },
      derivedFrom: [String]
    }],
    centroid: [Number],
    radius: { type: Number, min: 0 },
    density: { type: Number, min: 0 }
  },
  
  members: [{
    patternId: { type: String, required: true, index: true },
    membershipScore: { type: Number, min: 0, max: 1 },
    joinedAt: { type: Date, default: Date.now },
    contributionWeight: { type: Number, min: 0, max: 1 }
  }],
  
  quality: {
    cohesion: { type: Number, min: 0, max: 1 },
    separation: { type: Number, min: 0, max: 1 },
    stability: { type: Number, min: 0, max: 1 },
    significance: { type: Number, min: 0, max: 1 },
    confidence: { type: Number, min: 0, max: 1 }
  },
  
  performance: {
    applicationsCount: { type: Number, default: 0 },
    successRate: { type: Number, min: 0, max: 1, default: 0 },
    avgImpact: { type: Number, default: 0 },
    contextualPerformance: {
      type: Map,
      of: {
        context: String,
        applications: Number,
        successRate: Number
      }
    }
  },
  
  evolution: [{
    timestamp: { type: Date, required: true },
    event: {
      type: String,
      required: true,
      enum: ['created', 'merged', 'split', 'updated']
    },
    description: String,
    metrics: {
      memberCount: Number,
      avgSimilarity: Number,
      stability: Number
    },
    triggeringPatterns: [String]
  }],
  
  relationships: {
    parentCluster: { type: String, index: true },
    childClusters: [String],
    relatedClusters: [{
      clusterId: String,
      relationship: {
        type: String,
        enum: ['complements', 'conflicts', 'subsumes', 'overlaps']
      },
      strength: { type: Number, min: 0, max: 1 }
    }]
  },
  
  applicationRules: {
    minimumConfidence: { type: Number, min: 0, max: 1, default: 0.7 },
    requiredContext: [String],
    exclusionContext: [String],
    combinationRules: [{
      withCluster: String,
      rule: {
        type: String,
        enum: ['enhance', 'cancel', 'modify']
      },
      impact: Number
    }]
  },
  
  metadata: {
    tags: [{ type: String, index: true }],
    autoGenerated: { type: Boolean, default: true },
    lastEvaluated: { type: Date, default: Date.now },
    evaluationSchedule: {
      type: String,
      enum: ['hourly', 'daily', 'weekly', 'adaptive'],
      default: 'daily'
    },
    archived: { type: Boolean, default: false }
  }
}, {
  timestamps: true,
  collection: 'pattern_clusters'
});

// Indexes
PatternClusterSchema.index({ 'characteristics.type': 1, 'quality.confidence': -1 });
PatternClusterSchema.index({ 'members.patternId': 1 });
PatternClusterSchema.index({ 'metadata.archived': 1, 'metadata.lastEvaluated': 1 });
PatternClusterSchema.index({ 'performance.successRate': -1 });

// Instance methods
PatternClusterSchema.methods.addMember = async function(patternId: string, membershipScore: number) {
  const existingMember = this.members.find((m: IClusterMember) => m.patternId === patternId);
  
  if (existingMember) {
    existingMember.membershipScore = membershipScore;
    existingMember.contributionWeight = this.calculateContributionWeight(membershipScore);
  } else {
    this.members.push({
      patternId,
      membershipScore,
      joinedAt: new Date(),
      contributionWeight: this.calculateContributionWeight(membershipScore)
    });
  }
  
  await this.recalculateClusterMetrics();
  this.lastUpdated = new Date();
  return this.save();
};

PatternClusterSchema.methods.calculateContributionWeight = function(membershipScore: number): number {
  // Weight based on membership score and cluster size
  const sizeNormalization = 1 / Math.sqrt(this.members.length + 1);
  return membershipScore * sizeNormalization;
};

PatternClusterSchema.methods.recalculateClusterMetrics = async function() {
  // Recalculate quality metrics based on current members
  const memberCount = this.members.length;
  
  if (memberCount === 0) {
    this.quality.cohesion = 0;
    this.quality.confidence = 0;
    return;
  }
  
  // Calculate average membership score as proxy for cohesion
  const avgMembership = this.members.reduce((sum: number, m: IClusterMember) => sum + m.membershipScore, 0) / memberCount;
  this.quality.cohesion = avgMembership;
  
  // Update confidence based on member count and cohesion
  this.quality.confidence = Math.min(
    this.quality.cohesion * Math.log(memberCount + 1) / Math.log(10),
    1
  );
  
  // Add evolution event
  this.evolution.push({
    timestamp: new Date(),
    event: 'updated',
    description: 'Cluster metrics recalculated',
    metrics: {
      memberCount,
      avgSimilarity: avgMembership,
      stability: this.quality.stability
    }
  });
};

PatternClusterSchema.methods.evaluatePerformance = async function(context: string, success: boolean) {
  this.performance.applicationsCount += 1;
  
  // Update overall success rate
  const currentSuccesses = this.performance.successRate * (this.performance.applicationsCount - 1);
  this.performance.successRate = (currentSuccesses + (success ? 1 : 0)) / this.performance.applicationsCount;
  
  // Update contextual performance
  const contextPerf = this.performance.contextualPerformance.get(context) || {
    context,
    applications: 0,
    successRate: 0
  };
  
  const contextSuccesses = contextPerf.successRate * contextPerf.applications;
  contextPerf.applications += 1;
  contextPerf.successRate = (contextSuccesses + (success ? 1 : 0)) / contextPerf.applications;
  
  this.performance.contextualPerformance.set(context, contextPerf);
  this.lastUpdated = new Date();
  
  return this.save();
};

export const PatternClusterModel = model<IPatternCluster>('PatternCluster', PatternClusterSchema);